# 从0开始写一个简单的编译器

## 1.1 为什么要学编译原理/写编译器

在大学里有编译原理这门课程，相比于其他的专业课程来说，一般不会有机会在工作中学会编译器的构建技术。因此，正规学习这些技术是非常重要的。我们常常调侃学校老师的讲课是神婆画符，不知所云，这是因为理论常常是枯燥乏味的，占据课程的全部内容固然是不合理的，但是确实学好这门课程的关键前提和必由路径。想要融会贯通，我们必须上手实操。

既然如此，为什么不手动自己实现一个编译器呢？说干就干。

> 下面为知识记录历程，只记录本人未学到或觉得重要的知识点

## 1.2 了解语言基本概念

- **字母表（alphabet）**：书写语言时所有字符的有限集合
- **语言（language）**：某个字母表上字符串的集合
- **语法规则（syntax rules）**：用于定义构成语言的规则，即描述哪些字符串属于语言
- **语义规则（semantic rules）**：用于将语言中的每个字符串关联到某个含义的规则

## 1.3 编译器基本概念

编译器是用于将**源语言**转换为**目标语言**的程序。源语言一般是我们的高级语言，而目标语言是计算机可直接处理的语言。

### 1.3.1 编译器最简形式

由三部分组成：**单词符号管理器**、**语法分析器**和**代码生成器**。

- **单词符号管理器** *（token manager）*

  也叫**词法分析器（lexical analyzer，lexer）**/ **扫描器（scanner）**/ **单词符号处理器（tokenizer）**，主要做的是把字符流分解为有意义的单元，叫做 *单词符号（token）*。

- **语法分析器** *（parser）*

  接收词法分析器的结果（一个单词符号序列）并管理其结构；并进行处理，从中推导和收集代码生成器所需要的信息；最后将收集到的信息传给（调用）代码生成器。在这个过程中如果发现语法错误，则要完成适当的动作（比如，生成一个出错信息并中断编译）。

- **代码生成器** *（code generator）*

  基于语法分析器提供的信息输出目标程序。

![image-20241112164857260](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241112164857260.png)

### 1.3.2 编译器构建思路

我要构建的编译器，是以**语法分析器作为总控**的。具体来说就是，在语法分析器执行过程中，每当需要一个单词符号的时候就调用单词符号管理器，而在语法分析各处会调用代码生成器并传递代码生成器需要的信息。因此三个部分是并发工作的。

另一种可选的组织方式是用***遍（pass）***的方式组织上述编译器，在一遍操作中，读入输入文件，生成输出文件并作为下一遍的输出文件。这样就是一个顺序的结构，第一遍词法分析器读入源程序并输出一个包含对·应于源程序的单词符号构成的文件；第二遍，语法分析器读入单词符号文件，输出一个含有代码生成器所需信息的文件；第三遍，代码生成器读入这个文件，输出包含目标程序的文件。

## 1.4 运算符优先级

主要针对的是表达式的符号的优先级，根据串运算的优先级，从高到底（相同优先级运算的列于同一行）：

- 补运算`~`
- 星运算`*`、加运算`+`、问号运算`?`
- 连接运算
- 交运算`∩`
- 并运算`|`

## 1.5 正规表达式

正规表达式的精确定义是以**递归**形式给出的。

### 1.5.1 基本正规表达式

> 首先明确一点，空集和空串的集合是不一样的
>
> 空集（∅）和空串（""）虽然名字相似，但在集合论和计算机科学中有着不同的含义和性质。
>
> 1. **空集（∅）**：
>    - 空集是一个不包含任何元素的集合。
>    - 记作 ∅ 或者 { }。 
>    - 空集的性质是，它的元素个数为零。
>    - 在集合论中，空集是所有集合的子集。
>
> 2. **空串（""）**：
>    - 空串是长度为零的字符串（在计算机科学中使用）。
>    - 表示为两个双引号之间没有任何字符，即 ""。
>    - 空串的性质是它的字符个数为零，但它是一个字符串，不是集合。
>    - 空串可以在计算机程序中用于表示无内容的文本数据。
>

仅由单个字母表字母集合、空串集合、空集三种元素进行**并`|`、连接、星`*`**运算产生的表达式称为**基本正规表达式（基本正则表达式）**，英文是*base regular expression*。

### 1.5.2 正规语言

进一步地，如果r和s都是任意正规表达式，那么下列表达式也是正规表达式：

```
(r)
r|s
rs
r*
```

这是更复杂正规表达式的**构造规则**。构造规则不能够无限次使用，这表明正规表达式一定是有限长度的。

一个正规表达式可以定义（即代表）一个语言，如`b|c`定义语言`{b，c}`，这个语言叫做***正规语言（regular language）***。

很显然，一个语言可以由多种不同的正规表达式定义，换种说法，几个不同的正规表达式可能表示的是同一个语言。比如

```
bb*，b*b，λbb*，……
```

这里还要注意字母表中是否包含所用的运算符，如果包含，则存在表达式的二义性问题，如果使用的是运算符，则不做处理；如果使用的是想让这个运算符作为字母表中的字母，则需要用双引号将该符号括起来，起到转义的作用（实际只要起区分作用，什么符号都行）。

### 1.5.3 扩充的正规表达式

除了上面的基本正规表达式和更复杂表达式所用到的三种运算（并、连接、星）之外，还允许正则表达式拥有`~、+、？`等运算符，则称该表达式为**扩充的正则表达式**，英文叫做*extend regular expression* .

虽然是扩充版本，但是其功能不比前面的更复杂表达式强，每一个扩充的正规表达式一定有一个等价的未扩充正则表达式。也就是说，在语言定义方面，两者的功能相同，比如：

```
(b|c)？等价于λ|b|c
```

### 1.5.4 正规表达式的局限性

正规表达式是非常有用的，特别是在单词符号管理器（也就是词法分析器）的设计上，可以用正规式表示各种单词符号并提供给语法分析器，还可以关联到一些工具如JavaCC上来自动实现单词符号管理器。

正规表达式是有缺陷的，前面提到正规表达式的长度是有限制的，假设现有一个字母集`{b，c}`，对应的语言可以表示为

$PAIRED=\{b^ic^i:i\ge0\}=\{\lambda,bc,bbcc,bbbccc,……\}$

仔细思考，正规表达式确实无法表示，因为`i`没有上界，除非限定串的长度，否则是没有办法用正规式表示b和c的个数是一样的。

现在问题大了，在我们的高级程序语言中 ，有太多嵌套的结构体，比如if、while等结构，它们都用到了`{{……}}`这样的成对的嵌套结构，正规式显然是不能表示这类语句的。

## 2.1 什么是上下文无关文法

以实用的目的来看，我们起码要知道为什么要使用上下文无关文法。

编译器的工作之一就是确定源程序是否的确是属于源语言的一个串。如果不是，则需要采取相应的行动，汇报程序有*语法错误*。

那么编译器依据什么来检索源程序呢？首先最笨的方法——列举，肯定不行，字母表中的组合是列举不完的；自然而然的，正规文法也就不适用于这种没有字符串长度上限的情况；自然语言呢？也不行，描述篇幅过长，机器不能直接理解，也不够准确。

因此，我们顺理成章地推出了目标语法应该具有的特性，它必须让编译器拥有源语言语法的完整知识，并且得以某种形式嵌入到编译器中，满足

- 简洁，否则编译器可能会太大
- 准确，否则编译器不能正确检查语法
- 足够强大，足以完整描述语法
- 适合于某种有效的语法检查算法

***上下文无关文法（context-free grammar）***几乎可完美满足这几个条件！

文法是一个四元组

- 非终结符集合*（nonterminal alphabet）*，简写N
- 终结符集合*（terminal alphabet）*，简写T
- 产生式*（production）*的有限集
- 开始符号*（start symbol）*，N中的一个符号

之所以加上上下文无关的前缀，是因为上下文无关文法规定了产生式的形式（左侧是单个非终结符，右侧可以是终结符和非终结符的*闭包的连接），这样的规则表明非终结符的替换不依赖于周围的符号，也即“上下文无关”

相关的知识不再赘述

## 2.2 基于上下文无关语法的语言生成技术

- **直接右递归*（direct right recursion）***

  指左端的非终结符也出现在右端的最右边，这样就能生成一个从左到右的列表。

  ```
  A → xA
  ```

- **直接左递归*（direct left recursion）***

  和直接右递归相反。列表是从右到左生成的。

  ```
  A → Ax
  ```

- **直接中间递归*（direct interior recursion）***

  考虑之前提到过的：

  $PAIRED=\{b^ic^i:i\ge0\}=\{\lambda,bc,bbcc,bbbccc,……\}$

  这样的语言无法使用直接左递归和直接右递归来实现，采取中间递归的方式，以保证生成b和c的数目相同：

  ```
  A → xAy
  ```

  这样，程序设计语言中括号配对与嵌套的问题也解决了。

- **间接递归*（indirect recursion）***

  直接中间递归可以解决生成两个元素个数相等的列表，但不能生成多于两个的相同元素列表，比如：

  $TRIPLED=\{b^ic^id^i:i\ge0\}=\{\lambda,bcd,bbccdd,bbbcccddd,……\}$

  尽管这个语法在实际编译器设计中极少出现，但是了解其解决方案还是没有坏处的。

  接下来看间接递归（indirect recursion），间接递归的含义是，左端的非终结符不再一步直接调用自己，而是通过一个中间符号通过至少两步得到自己。间接递归是可以转化为等价的直接递归的，反之亦然。

- **分解*（in-parts）***

  适用于较为复杂的产生式

  $A→A_1A_2A_3...A_p,p\ge2$

  接着分解这些部分，共p份，对每部分使用上述的方法来解决，最后再组合起来，设计对应的中间量。

## 2.3 正规文法和右线性文法

正规文法是一个四元组，不要和之前的正规表达式弄混了。

正规文法首先是上下文无关文法，在上下文无关文法的限制之上又加了下述限制：

```
1. A → bB（A，B是任意的非终结符，可以是相同的）
2. A → b
3. A → λ
```

如果上下文无关文法的每个产生式都满足上述形式之一，则称其为***正规文法（regular grammar）***。可以看到正规文法可以是右递归的，但不能是左递归和中间递归形式的。

现在加上更多的产生式形式：

```
4. A → zB（A，B是任意的非终结符，可以是相同的，z是2个以上的终结符的序列）
5. A → z
```

一个文法的产生式如果是上述5种形式之一，就称该文法为***右线性文法（right linear grammar）***。

右线性文法可以被转换为正规文法，但是通常右线性文法的写法会更简洁直接一些（终结符序列的存在使得原本一步要被拆分为好几个中间步骤）。

---

可由正规文法所定义的语言是***正规语言（regular language）***，前面提到正规表达式所定义的语言也叫做正规语言，这是因为它们定义语言的能力恰好相同。也就是说正规表达式定义的任何语言也可以用正规文法来定义。

上下文无关文法和正规文法是包含的关系，由于每个正规文法也都是上下文无关文法，所以每个正规语言也都是上下文无关语言，但是反过来不是所有的上下文无关语言都是正规语言（比如PAIRED），因此前者要更为强大。

那既然如此为什么还要学正规文法？尽管大部分程序设计语言不是正规的，但是单词符号管理器分解源程序得到的各类单词符号几乎总是正规的。

比如可以这样描述一个字母开头、由字母(**L**etter)和数字(**D**igit)组成的字符串：

```
L(L|D)*
```

## 2.4 表的文法

程序语言中表经常出现。那么什么是表呢？我的理解是能够容纳一连串元素的组合的容器叫做表。和表相关的另一个重要的概念就是分隔符（分割相邻元素的符号）。根据表是否有元素划分为空表和非空表。

下面举一些表的例子：

```java
int x,y,z; //这里的关键字int之后是一个表（标识符列表），分隔符是逗号
```

```java
if(i==0){//这里的复合语句有三个赋值语句，也是一个表（赋值语句的表，注意分号不是分隔符，而是终止符，注意两者的区别）
    x=1;
    y=2;
    z=3;
}
```

```java
w+x-y+z //这样的表达式也是一个表，是运算数的表，分隔符为运算符号+和-
```

如何用文法来表示表呢？很简单，使用前面左右直接递归的知识就可以做到。也可以新增一个中间量L（**L**ist）表示表，这样有利于不同类型表的更改。

使用表达式的知识也能等价地表示。

## 3.1语法分析树

继续学习上下文无关语法。 首先介绍语法分析树，这是一种能很好地帮助我们学习上下文无关语法的图像表示，树每从一个节点向下延伸一层，就代表发生了一次推导（一次符号替换）。

考虑文法对串bcdd的推导

```
S → BD
B → bc
D → dD
D → λ
```

可以画出一棵推导的语法树：

```
                   S
                 /   \
                B     D
              /  \   /  \
             b    c  d   D
                        / \
                       d   λ
```

很直观对不对？把所有叶子结点连接起来就是最终的串。但是我们**不能从树中得知同层替换的先后顺序**，这就意味着交换同一层的替换非终结符（用大写字母来表示）的步骤顺序可以得到不同的推导，也就说明**一棵语法分析树可以对应不同的推导**。 

什么情况下语法分析树只会有一种确定的推导呢？那就是**所有的非终结符都在从开始结点起步的一条路径上**。

## 3.2 最左和最右推导

为了进一步研究语法分析树，我们引入**最左/最右推导**。

- **最左推导*（leftmost derivation）***

  每一步都替换最左边的非终结符

- **最右推导*（rightmost derivation）***

  每一步都替换最右边的非终结符

画出一个最左/右推导的语法分析树就可以看到，非终结符是以最左/右非终结符优先的**深度优先*（depth first）***顺序进行替换。

好了现在我们终于能开始讲**设计编译器的第一步**了：**写一个定义源语言的文法，然后为这个文法写一个语法分析器。**

构造的语法分析器一般是为了进行特定的推导，通常不是最左推导就是最右推导。它有两种实现方式：第一种是手动实现，第二种是通过**语法分析器的生成器*（parser generator）***来自动生成。

![image-20241114164926034](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411141649184.png)

## 3.3 语言-保持变换

上下文无关语言的**语言-保持变换*（language-preserving transformation）***通过某种不影响所生成语言的方式对文法进行修改。即修改后的新文法和原文法都生成相同的语言。

> 为什么要进行这样的变换？
>
> 答案是，语法分析算法一般需要十分特殊形式的文法，我们一般要对给定文法做变换使其变成程序所需要的形式。
>
> 什么？你问我为什么不一开始就写成所需形式的文法？这是因为有时更改一个不符合格式的文法要比直接写一个符合格式的文法更简单些。

## 3.4 文法的错误和缺陷之处

我们在实际编写编译器第一步的时候，一定要对自己所写的文法进行检查，不然文法通常不能正确定义想要的语言。下面就介绍一些典型的问题和用以解决的语言-保持变换。

## 3.5 二义文法

前面提到，一棵语法分析树有可能对应两个不同的推导，这很正常，这棵语法分析树对应的是同一个文法。但是有一种情况，一种文法有两个以上的语法分析树，这样的文法叫***二义文法（ambiguours grammar）***，从英文就能看出，我们并不希望这种情况出现。幸运的是，我们几乎总是可以将二义文法变换到等价的（即生成相同语言）的无二义性文法。

### 3.5.1 重构法

这是我自己起的名字，其原理就是*研究该二义文法所确定的语言，再根据该语言写出新的无二义的文法*。一般在重写的过程中我们会严格按照从左到右或从右到左生成串的规则来重构，这样很少会出现二义文法。 

### 3.5.2 使用单行道产生式

***单行道（one-way street）***是一类产生式。文法之所以为二义，是因为生成同一个语言使用产生式的顺序是不定的，转换到无二义文法的技巧很简单，就是强制产生式使用特定的顺序（通过引入新的非终结符来实现），这样某一个产生式2就好像它前面那个产生式1的单行道，一旦离开了产生式1,进入产生式2，就没有回头路了，这就是起名单行道的原因。

### 3.5.3 删除法（要小心）

有时，文法有两个或更多的产生式在完成相同的任务，因此引发二义性。因此我们可以在保持生成语言等价的情况下删除一些产生式，注意！**不能让原来的文法变得不等价**。

---

说了这么多转换二义性文法的方法，我们要知道不是所有的二义的上下文无关语法都能转换。有些二义性是无法消除的，因此也就不存在消除文法二义性的通用算法。

## 3.6 确定可致空的非终结符

如果一个非终结符可以生成空串，则称它是**可致空的*（nullable）***。有一个算法可以标记所有可致空的非终结符，这里不赘述了。

## 3.7 消除λ产生式

通常我们可以将上下文无关文法的一个两端非空的产生式看作一个**替换规则**，把一个λ产生式（右端是λ的产生式）看作是一个**删除规则**。

考虑这个问题：如果一个非终结符在推导的最后会被删除，为什么还要在一开始生成这个非终结符（生成的含义是原本右边没有的，经过推导后在右边出现了）？如果不生成这个非终结符，那么就无须删除它了，如果不是必须删除它，也就不需要λ产生式了，因此理论上来说是可以把含有λ产生式的文法转换为无λ产生式的文法的。比如：

```
1. S → dBC
2. B → bB
3. B → λ
4. C → cC
5. C → λ
```

要删除λ产生式，则需要新增产生式，实际操作就是把λ产生式带入所有用到左端非终结符的式子中去。最后的结果为：

```
1. S → dBC
2. S → dC
3. S → dB
4. S → d
5. B → bB
6. B → b
7. C → cC
8. C → c
```

这样的方法会在一种情况下破例：文法能生成空串的情况。这样无论如何都删不干净λ表达式，所以只能做到删除λ表达式后新文法能够完成所有除了生成空串以外的事情。

## 3.8 消除unit产生式

一个产生式的左端和右端仅有一个非终结符组成，称之为**unit产生式**。

和3.7类似的方法，消除unit产生式只需要：增加产生式，使得被消除的产生式变为没必要的。这个比较简单，只需要把右边的非终结符用所有能推导的终结符来代替就好了。

## 3.9 消除无用非终结符

**无用非终结符*（useless nonterminals）***指的是从未在“成功”推导中使用的非终结符，一共有两类：**不可达的**和**死的**。

**不可达非终结符*（unreachable nonterminal）***就是一定不会出现在始于开始符号的某个推导中的非终结符（直接的和间接的）。有一个类似的算法可以用于标记，看了一下，主要原理还是传递性，不再赘述。

**死的非终结符*（dead  nonterminal）***指那些不能生成终结符串（这里指的是纯血非终结符串，包含非终结符不算）的非终结符。这样的包含死非终结符的产生式我们都可以删除而不影响文法生成的语言。

要注意的是，在实践中我们会发现消除死的和消除不可达的非终结符的顺序是有讲究的，消除死的非终结符可能会生成新的不可达非终结符，相反则不会。

因此必须先消除dead的，再消除unreachable的，这样就不会出现先消除了unreachable的然后再消除dead的过程中又出现unreachable的情况了。这条规则被称为**“duh规则”**。

## 3.10 递归的转换

前面提到过了直接左/右递归的定义，现在我们来研究怎么消除递归。递归并不是一种错误，而是某些情况下是我们所不期望的产生式的形式。

消除递归的方法很简单，只要和原来的方向反向地生成表即可，也就是说原本是左递归的形式，只要将其变为右递归即可。

递归包括直接递归和间接递归，但间接递归可以转换为等价的直接递归。考虑下面的例子：

```java
1. S → Af // 由于右端是S，我们称之为S的产生式
2. A → Sb
3. A → Ac
4. A → Bd
5. B → e
```

在消除左递归时，将右端以某个非终结符开始的每个产生式看作是**指向**这个非终结符。

因此我们可以这么说：产生式1是指向A的，产生式2是指向S的，产生式3是指向自身的，产生式4是指向B的，产生式5是无所指的（右边没有非终结符）。

至此，我们可以将消除左递归的一般技术总结如下：

1. 根据产生式左端对产生式分组
2. 依序处理每组产生式。对每个产生式，
   1. 首先使用替换技术消除向后指的产生式
   2. 然后使用消除直接左递归技术消除指向自身产生式

to be continued

## 3.11 增加空串到语言

这是一种非语言保持的变换，为了向我们文法所定义的语言中加入空串，不能简单地加入产生式`S → λ`，因为不知道是否存在右端有S的产生式，这样就会导致出现原语言中不曾出现的新句子。

正确的做法是创造一个新的开始符号S‘，并让`S’→S`，这样就能保证任何产生式右端都没有S‘了。

当然我们注意到新增的这个产生式是一个unit产生式，所以有需要的话可以用之前的方法来消除。

## 4.1 算术表达式文法

下面将语言的学习从抽象的视角转到一类“真实“的语言——即算术表达式语言。这是我们的简单编译器要实现的功能中重要的一部分语法。算术表达式语言也是由上下文无关语法生成的。

由简入繁，让我们把四则运算限制到至多三个运算数b\c\d的`+、*`运算，可以使用括号。其他情况都可由此扩展。

给出算术表达式语言的第一个简单文法，将终结符用引号括起，连续的终结符或非终结符之间用空格分隔：

```java
expr → expr "+" expr
expr → expr "*" expr
expr → "b"
expr → "c"
expr → "d"
expr → "(" expr ")"
```

仔细思考，这样的文法是不能表示乘法的优先级高于加法的，也就是说对于同一个包含加和乘的算式，该文法因具有**乘-加优先级二义性**，所以会构造出不同的语法分析树来。接下来作出改进：

```java
expr → expr "+" expr
expr → term
term → term "*" term
term → "b"
term → "c"
term → "d"
term → "(" expr ")" //要注意这里仍然可以强制加法优先级比乘法高，所以括号里是expr
```

使用的是之前消除二义性的单行道技术，通过加入新的非终结符`term`来实现。产生式2是单行道，强制在语法分析树中乘法位于加法的下面，从而具有更高的优先级。我们可以总结出：

> 要使一个运算具有更高的优先级，那么就要迫使它在语法分析树中位于更低的位置。

但是还有一个问题没有解决，那就是**同级运算符并列所造成的二义性仍旧没有得到解决**，我们知道加法和乘法连续进行时顺序应该是从左到右，因此`+`和`*`应该都是左结合的。解决办法就是：强制以从右到左的顺序生成加/乘法运算符和结合起来的项。新文法如下：

```java
//这个文法适合自下而上的语法分析
expr → expr "+" term
expr → term
term → term "*" factor
term → factor
factor → "b"
factor → "c"
factor → "d"
factor → "(" expr ")" //要注意这里仍然可以强制加法优先级比乘法高，所以括号里是expr
```

新增的unit产生式能够保证同级运算时运算符是左结合的，也就是说右边的运算项需要至少多一层推导才能变成终结符。这个新文法实际是等价于第一个文法的，但是提供了适当的优先级和结合性的信息。

最后还有一层可选的变化是：**去除左递归**

有些语法分析技术和文法的左递归不兼容，因此需要使用前面的把左递归转换成右递归的方式来消除：

```java
//这个文法适合自上而下的语法分析
expr → term termList
termList → "+" term termList
termList → λ
term → factor factorList
factorList → "*" factor factorList
factorList → λ
factor → "b"
factor → "c"
factor → "d"
```

最后两个文法非常重要，分别描述了**自下而上*（bottom-up）***和**自上而下*（top-down）***的语法分析方式。可以看到前者是**左递归**的，适合自下而上；后者是**右递归**的，适合自上而下。

## 4.2 BNF范式

表示上下文无关语法的另一种形式。不详细展开。

## 4.3 语法图

表示上下文无关语法的另一种形式。不详细展开。

## 4.4 抽象语法树和三地址码

这是两种编译器常用的内部表示。

编译器的语法分析器通常是将源码翻译到抽象语法树。然后编译器的其他部分在抽象语法树上进行操作。例如，**语义分析器*（semantic analyzer）***可以增加属性（比如数据类型）到树上，同时进行类型检查。**优化器*（optimizer）***可以对树修改，以便代码生成器从它生成的最终目标代码更加有效。

本编译器遵循参考书的设计，主要组成部分包括单词符号管理器、语法分析器和代码生成器。语义分析器和优化器的部分将被整合到语法分析器和代码生成器中。因此我们不需要为这些功能单独构造功能部件。

## 5.1 自上而下构造语法分析树

## 5.2 失败的语法分析

## 5.3 确定的语法分析器

## 5.4 借助栈的语法分析器

## 5.5 用表来表示栈式语法分析器

## 5.6 处理不以终结符领头的产生式

## 5.7 自己写一个简单的栈式语法分析器

### 任务

自上而下栈式语法分析器

### 文法

```
1）S → bScA
2）S → cbd
3）A → bcA
4）A → d
```

### 分析

首先是一个栈式的语法分析器，输出结果应该包括输入内容和语法分析结果。输入内容以程序实参（`args`）的方式给出。

当然读入数据的功能由一个可以称得上是”**词法分析器**“的部件来实现，但实际功能只包括读入数据与传递数据给parser，没有真正实现分词功能（因为都是单字母终结符，实际无词可分）。

第二个部件是主角——**语法分析器**，语法分析器接受词法分析器传递的数据，并能够利用已有的工具类`Stack`来实现`pop、push`操作，此外还有操作`advance`和一个最终表示状态的`boolean`返回值（当然也可以就用print来表示，因为没有后续的操作了）。

在开始写代码之前最好要列出语法分析表，并基于这个表来设计switch循环里的语句。

本次实践对应语法分析表如下：

![IMG_8504](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411161916077.JPG)

结果示例：

#### 接受情况（accept）

![image-20241116172025304](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411161720401.png)

#### 拒绝情况（reject）

![image-20241116172007240](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411161720391.png)

### 代码实现

`MyParser.java`

```java
package com.niko.parser;

/*自上而下栈式语法分析器
 *
 *   1）S → bScA
 *   2）S → cbd
 *   3）A → bcA
 *   4）A → d
 * */
import java.util.*; // 引入栈和词法分析器类

/*
 * @author：niko
 * 主类
 * */
class Start{
    public static void main(String[] args) {//注意args是一个String数组！
        //主要做一些实例化的操作
        ArgsTokenMgr atm=new ArgsTokenMgr(args);
        //注意这个词法分析器被用作初始化参数
        SimpleParser parser = new SimpleParser(atm);
        //进行词法分析
        parser.parse();
    }
}

class ArgsTokenMgr{
    //域
    private int index;//用于指示当前输入串位置下标
    private String input;//用于存储输入字符串

    //初始化方法
    public ArgsTokenMgr(String[] args){
        if(args.length>0){
            input=args[0];
        }else{//无命令行参数处理为空串
            input="";
            System.out.println("**no parameter entered!");
        }
        index=0;
        System.out.println("input = " + input);
    }

    //工具方法
    public char getNextToken(){
        if(index < input.length()){//可以用String类的方法
            return input.charAt(index++);//返回下一个字符
        }else{//说明全部字符已经读入了，需要返回结束标记
            return '#';
        }
    }
}
class SimpleParser{
    //域
    private ArgsTokenMgr atm; // 单词符号管理器
    private Stack<Character> stack; // 语法分析器栈
    private char currentToken; // 当前单词符号

    //初始化方法
    public SimpleParser(ArgsTokenMgr atm){
        this.atm=atm;//注意包含关系，包含的类要一并初始化
        advance();//初始化currentToken
        stack=new Stack<>();
        stack.push('$');//第一个肯定是栈底标记
        stack.push('S');//开始符号入栈
    }

    //辅助方法
    public void advance(){
        currentToken= atm.getNextToken();
    }

    //主要方法:因为没有后续步骤，所以返回值为空
    public void parse(){
        boolean isDone = false;//控制循环出口

        //用while循环来表示每一步的语法分析
        while(!isDone){
            switch(stack.peek()){//有关这个方法的信息见下图
                //这里填充具体的文法逻辑：文法不同，下面的代码也不同

                case 'S':
                    if (currentToken == 'b') {
                        stack.pop(); // 使用产生式1
                        stack.push('A');//这里用到了Java的自动装箱、拆箱的机制
                        stack.push('c');
                        stack.push('S');
                        advance();
                    } else if (currentToken == 'c') {
                        stack.pop(); // 使用产生式2
                        stack.push('d');
                        stack.push('b');
                        advance();
                    } else {
                        isDone = true; // 拒绝状态
                    }
                    break;

                case 'A':
                    if (currentToken == 'b') {
                        stack.pop(); // 使用产生式3
                        stack.push('A');
                        stack.push('c');
                        stack.push('b');
                        advance();
                    } else if (currentToken == 'd') {
                        stack.pop(); // 使用产生式4
                        advance();
                    } else {
                        isDone = true; // 拒绝状态
                    }
                    break;

                case 'b':
                case 'c':
                case 'd':
                    if (stack.peek() == currentToken) {
                        stack.pop(); // 匹配栈顶终结符
                        advance();
                    } else {
                        isDone = true; // 拒绝状态
                    }
                    break;

                case '$': // 空栈退出
                    isDone = true;
                    break;
            }
        }

        //用if语句判断是否为接受状态
        if(currentToken=='#' && stack.peek()=='$'){//如果输出串读取完毕并且已到栈底（表示没有非终结符了）则接受
            System.out.println("accept");
        }else{//其余的情况都为拒绝
            System.out.println("reject");
        }

    }

}
```

可以看到peek的作用是*返回栈顶并不用弹出*。

![image-20241116175140641](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411161751735.png)



## 6.1 LL1文法



## 7.1 表驱动的栈式语法分析器

之前所写的借助栈的语法分析器的主体逻辑部分是一个多分支选择Switch语句，对应的是所给定的文法：

```
1）S → bScA
2）S → cbd
3）A → bcA
4）A → d
```

当这个文法发生变化但是我们又想用同一个程序来分析的时候，我们就不得不修改这个switch语句。要是能有一个相同的程序能否处理不同的文法，又该怎么做呢？

一个简单的思路是把这个问题看作经典的数据库硬编码的问题，之前学习JDBC的时候对于数据库的查询语句就是以硬编码的字符串的方式嵌入到代码当中，修改成本比较高，解决方案用的是myBatis框架的配置文件，具体使用的数据都保存在一个配置文件里，具体代码中是不变的读取数据的操作。

同样道理，把语法分析器的实现分为两个不同的部分：数据部分和代码部分。代码部分对于任意文法无需变动就可以使用；数据部分通过表来控制，用来描述文法。使用**栈式语法分析器的生成器**来完成这个任务，它以一个文法为输入，输出构成表驱动语法分析器的数据部分（也就是表）。

```java
/* 针对以下文法的自上而下表驱动栈式语法分析器
   Selection set
   0) S → fBC {f}
   1) B → bb {b}
   2) B → CD {c, d, e}
   3) C → cC {c}
   4) C → lambda {d, e, #}
   5) D → dD {d}
   6) D → e {e}
*/
import java.util.*; // 装入 Stack 和 Scanner 类

class ArgsTokenMgr{
    //域
    private int index;//用于指示当前输入串位置下标
    private String input;//用于存储输入字符串

    //初始化方法
    public ArgsTokenMgr(String[] args){
        if(args.length>0){
            input=args[0];
        }else{//无命令行参数处理为空串
            input="";
            System.out.println("** no parameter entered! **");
        }
        index=0;
        System.out.println("input = " + input);
    }

    //工具方法
    public char getNextToken(){
        if(index < input.length()){//可以用String类的方法
            return input.charAt(index++);//返回下一个字符
        }else{//说明全部字符已经读入了，需要返回结束标记
            return '#';
        }
    }
}

class Fig0804 {
    public static void main(String[] args) {
        ArgsTokenMgr tm = new ArgsTokenMgr(args); // 构造单词符号管理器
        Fig0804Parser parser = new Fig0804Parser(tm); // 构造语法分析器
        parser.parse(); // 进行语法分析
    }
}

interface DataPart {
    String tokens = "bcdef#"; // 单词符号列表
    String nonTerms = "SBCD"; // 非终结符列表
    String[] pTab = {"CBf", "bb", "DC", "Cc", "", "Dd", "e"}; // 产生式右端逆序存放
    int[][] parseTable = {
            {-1, -1, -1, -1, 0, -1},
            {1, 2, 2, 2, -1, -1},
            {-1, 3, 4, 4, -1, 4},
            {-1, -1, 5, 6, -1, -1}
    };
}

class Fig0804Parser implements DataPart {
    private ArgsTokenMgr tm;
    private Stack<Character> stk;
    private char currentToken;

    public Fig0804Parser(ArgsTokenMgr tm) {
        this.tm = tm;
        advance();
        stk = new Stack<>();
        stk.push('S'); // 用开始符号初始化栈
    }

    private void advance() {
        currentToken = tm.getNextToken();
    }

    public void parse() {
        int nonTermIndex, tokenIndex, pNumber;

        while (true) {
            tokenIndex = tokens.indexOf(currentToken); // 当前单词符号转下标
            if (tokenIndex == -1 || stk.empty()) break;

            nonTermIndex = nonTerms.indexOf(stk.peek()); // 栈顶符号转下标

            if (nonTermIndex >= 0) { // 栈顶是否为非终结符
                pNumber = parseTable[nonTermIndex][tokenIndex];
                if (pNumber < 0) break; // -1 表示拒绝

                stk.pop();
                for (int i = 0; i < pTab[pNumber].length(); i++)
                    stk.push(pTab[pNumber].charAt(i));
            } else if (currentToken == stk.peek()) { // 栈顶是否匹配当前单词符号
                stk.pop();
                advance();
            } else {
                break;
            }
        }

        if (currentToken == '#' && stk.empty())
            System.out.println("accept");
        else
            System.out.println("reject");
    }
}
```

## 8.1 一个简单的递归下降语法分析器

```java
/*
* 以下文法的递归下降语法分析器
*                   Selection Set
*   1) S → BD         {b,c}
*   2) B → bB         {b}
*   3) B → c          {c}
*   4) D → de         {d}
* */

class MyParser {
    public static void main(String[] args) {

        //构造单词符号管理器
        ArgsTokenMgr tm =new ArgsTokenMgr(args);
        //构造语法分析器
        RDParser rp = new RDParser(tm);

        try{
            rp.parse();
        }
        catch(Exception e){
            System.err.println(e.getMessage());
            System.err.println("reject");
            System.exit(1);
        }

        //到达接受点
        System.out.println("accept");
    }
}

class ArgsTokenMgr{
    //域
    private int index;//用于指示当前输入串位置下标
    private String input;//用于存储输入字符串

    //初始化方法
    public ArgsTokenMgr(String[] args){
        if(args.length>0){
            input=args[0];
        }else{//无命令行参数处理为空串
            input="";
            System.out.println("** no parameter entered! **");
        }
        index=0;
        System.out.println("input = " + input);
    }

    //工具方法
    public char getNextToken(){
        if(index < input.length()){//可以用String类的方法
            return input.charAt(index++);//返回下一个字符
        }else{//说明全部字符已经读入了，需要返回结束标记
            return '#';
        }
    }
}

class RDParser{
    private ArgsTokenMgr tm;
    private char currentToken;
    public RDParser(ArgsTokenMgr tm) {
        this.tm=tm;
        advance();
    }


    private void advance() {
        currentToken = tm.getNextToken();
    }

    private void consume(char expected){
        if(currentToken==expected){
            advance();
        }else
            throw new RuntimeException("expecting " + expected + " but got "+currentToken);
    }

    public void parse() {
        S();
        if(currentToken!='#') //尾部垃圾测试
            throw new RuntimeException("expecting '#' but got "+currentToken);
    }

    private void S() {
        //使用S → BD
        B();
        D();
    }
    private void B() {
        switch(currentToken){
            case 'b':
                consume('b');
                B();
                break;
            case 'c':
                consume('c');
                break;
            default:
                throw new RuntimeException("expecting 'b' or 'c' but got "+currentToken);
        }
    }
    private void D() {
        consume('d');
        consume('e');
    }


}
```

## 9.1 写一个简单的递归下降语法翻译器

包括任何编译器都有的三个基本部分：单词符号管理器、语法分析器和代码生成器。当然，代码生成器是最小的，仅有一个动作语句，嵌在语法分析器中。

```java
```



- [ ] 尾递归问题
