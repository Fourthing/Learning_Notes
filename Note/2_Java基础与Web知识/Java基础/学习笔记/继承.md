# 继承

继承是一种“is-a”关系，比如经理和普通员工的待遇存在一些差异，但是大体上都属于公司雇员`Employee`，为经理定义的新类应该在包含原有功能和域的基础上新增一些功能和域，这就用到了继承（Java中的关键字是`extends`）。

> C++注释：Java与C++定义继承类的方式十分类似，使用关键字`extends`代替了`：`但是Java中所有的继承都默认是公有继承，没有C++中的私有继承和保护继承。

## 类、超类和子类

### 超类和子类

关键字`extends`表明正在构造的新类派生于一个已存在的类。已存在的类被称为**超类（superclass）**、**基类（base class）**或**父类（parent class）**；新类被称为**子类（subclass）**、**派生类（derived class）**或子类**（child class）**。超类和子类是Java程序员较常使用的术语，而其他语言种类的程序员可能更加偏爱使用父类和子类。这些都是在继承时使用的术语。

尽管`Employee`类是一个超类，但并不是因为它位于子类之上或拥有比子类更多的功能。恰恰相反，子类比超类拥有的功能会丰富。例如，通过`Manager`类的源代码发现，`Manager`类比`Employee`类封装了更多的数据，拥有更多的功能。

子类在调用超类的方法时,应该使用一个关键字`super`来表明是父类中的方法。如果子类想获取一个父类中的域值，是不能直接访问的，因为这个域值在父类中一般是私有的，只能通过父类的公有接口也就是各种`getter`来访问。

> 注意：有些人认为super与this引用是类似的概念，实际上，这样比较并不恰当。这是因为super不是一个对象的引用，不能将super赋予另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。C++中用的是`父类名字::方法名`的形式，比如`Employee::getSlary`

### 阻止继承的final类和方法

`final`关键字除了用来定义静态变量和静态方法之外，还可以用来禁止继承，一个用`final`修饰的类代表着该类不允许被扩展，我们称之为**final类**。final类中的所有方法自动地会成为**final方法**（不包括域），final方法不能被重写/重载/覆盖。

> 复习：`final`表示“最终的”，用`final`修饰的类不能被继承，用`final`修饰的方法不能被重载，用`final`修饰的域在初始化后不能被重新赋值

```java
final class Excutive extends Manager{...}
```



### 子类如何直接访问超类方法或域（不用super关键字）

先前的学习中我们提到，最好将类中的域标记为`private`，而方法标记为`public`。任何声明为`private`的内容对其他类都是不可见的。即使是子类也不能访问超类的私有域。

然而，在某些时候，人们希望超类的某些方法允许被子类访问，或者允许子类的方法访问超类的域。只需要将这些方法标记为`protected`。

例如，如果将超类`Employee`中的`hireDay`声明为`protected`，而不是`private`私有的，`Manager`类的方法就能直接访问`Manager`对象中的`hireDay`，当然`hireday`除外的其他域仍然不能直接访问，这种限制有助于避免滥用继承机制，使得子类能获得适当的保护机制。

在实际应用中，`protected`仍然使用的比较少，一定程度上对封装性有所破坏（体现在含protected的子类继承上）。

关于`protected`的一个最好的示例是Object类中的`clone`方法。

> C++注解：实际上，Java中的受保护部分对所有子类及同一个包中的所有其他类都可见。这与C++中的保护机制有所不同，Java中的protected概念要比C++中的安全性差。



### 覆盖/重载

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应选择适用的方法放在超类中，而将具有特殊用途的方法放在子类中，这种将用于功能放到超类的做法，在面向对象程序设计中十分普遍。

然而，超类中的某些方法对于子类`Manager`并不一定适用。例如，在`Manager`类中的`getSalary`方法应该返回薪水和奖金的总和。因此，需要提供一个新的方法来**覆盖** *（override）*超类的这个方法。



### `super`在构造器中的使用

子类的构造器也可以用到`super`这个特殊关键字，表示调用父类的构造方法初始化一些**共有**的域值。因为子类不能访问超类的私有域，所以必须利用超类的构造器来对这部分私有域进行初始化。注意！这句语句必须是子类构造器的第一句语句。

```java
    // 超类构造器
    public Animal(String name,String gender) {
        this.name = name;
        this.gender = gender;
    }
    // 子类构造器
    public Dog(String name, String gender,String breed) {
        // 调用超类构造器
        super(name,gender);
        //进行子类特有属性的初始化
        this.breed = breed;
    }
```

如果子类的构造器没有显式地调用超类的构造器，则将**自动调用超类的构造器**（没有参数）的构造器。如果子类的构造器没有显式地调用超类的构造器并且超类没有不带参数的构造器，则Java编译器将报告错误。



### 多态与动态绑定

一个对象变量可以引用多种实际类型的现象被称为**多态**（polymorphism）。在运行时能够自动选择调用对象的哪个方法的现象称为动态绑定（dynamic binding）。

#### 怎么判断实际使用中是否要设计为继承？

- 首先也是最主要要看的就是是否复合“is-a”（是）规则，表明子类的每个对象也是超类的对象，每个经理也肯定是员工，反之每个员工不一定是经理。

- 其次，看是否符合所谓的“**置换法则**”，置换法则要求程序中出现超类对象的任何地方都可以用子类对象置换。

  ```java
  //比如，将一个子类的对象赋值给超类变量
  Employee e;
  e = new Employee(...);
  e = new Manager(...);//这样也可以
  ```

我们看到在Java中对象变量是多态的，超类的变量可以引用任何一个子类的对象，但是反之就会报错（员工不一定是一个经理）。

#### 关于动态绑定

在Java中，当你调用一个方法时，编译器并不会立即决定调用哪个具体的方法实现，而是在运行时根据对象的实际类型来确定。这种机制称为动态绑定。

之前学习类构造器重载的时候提到，一个方法的签名，也就是让编译器将它与其他的方法区分开来的依据，就是一个方法的方法名和其参数列表（不包括返回值），实际完成动态绑定的过程也是依次寻找方法名和参数列表的过程。

如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。

### 继承层次

继承不是只能有一层，可以有多层的继承，派生出好多好多的类来，成为一个完整的子孙继承链。

> ！C++注释：但是Java不支持多继承，Java中的多继承功能的实现需要用到**接口（Interface）**

### 对象之间的强制类型转换

参考 数据类型与变量 笔记中的知识，对象之间的类型转换方法还是和基本变量之间的转换方法是一样的。

```java
Manager m = new Manager(...);
Employee e = (Employee)m;
```

将一个值赋给对象时，编译器会首先检查是否允许该操作。根据上面的“置换法则”，超类对象是允许接受子类赋值的，反过来，若子类想接受超类的赋值，就必须进行类型转换才能通过运行检查。

但是一般来说在进行继承链上从上而下的类型转换时，很可能发生`ClassCastException`异常，在进行类型转换之前，先使用`instanceof`运算符来检查是否能够成功转换。

```java
Employee e = new Employee(...);
if(Employee instanceof Manager){
    Manager m = (Manager) e;
    //设置子类比超类多出来的属性
    m.setBonus(...);
}
```

---

## 抽象类

试想`Employee`和`Student`类有无共同点？当然是有的，实际上我们可以用一个`Person`类来存放两者共同的变量和方法，来提高代码的重用性和减少程序体量。

抽象方法必须用 `abstract` 关键字进行修饰。**如果一个类含有抽象方法，则称这个类为抽象类**（言外之意就是抽象类还可以包含具体变量和具体方法），抽象类必须在类前用 `abstract` 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。

抽象类就是为了继承而存在的，它们的具体实现是在子类中。扩展抽象类可以有两种选择：

- 一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；
- 另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。

类即使不含抽象方法，也可以将类声明为抽象类。
抽象类不能被实例化。也就是说，如果将一个类声明为`abstract`，就不能创建这个类的对象。但是可以定义抽象类的对象变量！

```java
Person p = new Person(...);//抽象类不能实例化！
Person p = new Student("张三"，...);//但可以引用非抽象子类的对象！
```

### 抽象类≠接口

接口相对于抽象类来说，它的抽象程度更上一层，接口中的方法必须都是抽象方法，而且没有具体方法和具体域。

后面会详细分析接口。
